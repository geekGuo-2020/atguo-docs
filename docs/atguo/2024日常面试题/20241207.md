---
title: 20241207
date: 2024-12-07 19:09:30
permalink: /pages/7b10da/
categories:
  - vuepress-theme-vdoing
  - docs
  - Atguo
  - 2024日常面试题
tags:
  - 
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---
# 双非24届，准备春招，缓存组件项目，抖音短视频项目。

## 挑一个最复杂的模块介绍下流程。发视频&获得视频列表。MinIO，如何实现刷过的视频不会再刷到。

## 如果视频特别大，会做压缩吗？这两个模块你觉得哪里还能优化？

## 敏感词过滤怎么实现的？除了前缀树还有其他的吗？DFA算法知道吗？



## 登录密码增强怎么做的？MD5是加密算法吗？为啥可以防止彩虹表攻击？随机加盐、多次hash、



## 对称加密和非对称加密区别是啥？

- 对称加密，指的是需要对加密和解密使用相同密钥的加密算法。

- 非对称加密，指的是加密和解密使用不同密钥的加密算法，也称为公私钥加密。

### 视频的唯一的URL地址生成方式？雪花算法。为啥不用uuid？雪花算法用的哪个工具类？



### 进程和线程、协程有啥区别？Java是多进程还是多线程，Java的线程是如何实现的知道吗。

什么语言支持协程？go、java

- ## 进程
  
  进程具有一个独立的执行环境。 进程是程序在计算机上的一次执行活动 。通常情况下，进程拥有一个完整的、私有的基本运行资源集合。特别地，每个进程都有自己的内存空间。
  
  进程往往被看作是程序或应用的代名词，然而，用户看到的一个单独的应用程序实际上可能是一组相互协作的进程集合
  
  ## 线程
  
  线程有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。线程是在进程中存在的，每个进程最少有一个线程。线程又如下特点：
  
  1. 线程共享进程的资源，包括内存和打开的文件。线程之间的通信不用进行系统调用，更节约时间
  2. 线程更轻量，线程实体包括程序，数据和TCB
  3. 线程是调度的基本单位
  
  ## 协程
  
  所谓的协程，是英语翻译过来的（Coroutine），也叫纤程。通过Coroutine来理解，是协作的程序。它其实是不能和进程，线程相提并论的，因为协程是用户态的东西，不会被OS感知到的。但是因为GoLang的大火，大家总是把他们放到一起来比较，所以在这里也一起讲了。
  
  对于多次IO操作来说，我们可以用多线程来完成，但是多线程会引起资源竞争，导致CPU算力的浪费。为了避免这种情况，我们也可以用异步的方式，但是异步的方式会引起callback hell，严重影响了代码的可读性。
  
  所以就需要协程，不让OS通过竞争的方式决定调用哪些线程，而是由用户自己决定如何去执行逻辑。它可以让我们用逻辑流的顺序去写控制流，而且还不会导致操作系统级的线程阻塞。因为协程是由应用程序决定的，所以任务切换的上下文也会交给了用户态来保存。目前GO和Ruby等编程语言都实现了协程，Java也在19的时候引入了协程。

### 进程间通信方式有哪些？管道（半双工和全双工区别）、

- 管道、命名管道、消息队列、共享内存、信号量、套接字



### CPU和GPU有啥区别？为啥大模型训练用GPU。

- CPU是计算机的大脑，专门用于执行各种通用任务，如操作系统管理、数据处理、多任务处理等。它的架构设计旨在适应多种任务，具有较少的核心，但每个核心非常强大且灵活。
  
  GPU最初是为图形渲染和图像处理而设计的，因此其架构包含大量的小核心，适合并行处理。这些核心可以同时处理多个相似的任务，使其在某些计算任务中表现得比CPU更高效。
  
  **CPU核心数少、GPU核心数多；CPU适合做各种复杂任务，GPU适合做重复性的计算任务。**

- GPU在并行计算方面的出色表现，它们在加速深度学习训练过程中发挥了关键作用。

### TCP为啥需要三次握手？TCP对头阻塞是啥？能解决吗？

- TCP三次握手验证了client和server的收包和发包能力。

- 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：**客户端的发送能力、服务端的接收能力是正常的。**
  
  第二次握手：服务端发包，客户端收到了。**这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。**
  
  第三次握手：客户端发包，服务端收到了。**这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。**
  
  所以，只有**三次握手才能确认双方的接收与发送能力是否正常。**



### ping的原理是什么？ping localhost没网吗？ping需要端口吗？

- ping的原理是基于ICMP（Internet Control Messages Protocol）来工作的，即因特网信报控制协议；

- ping命令利用了ICMP两种类型的控制消息：“echo request”（回显请求）、“echo reply”（回显应答）。

## CMS的垃圾回收过程。为啥要分成4步。为啥初始标记和重新标记需要STW？什么东西可以当做GC Root。跨代引用怎么办？fullgc和younggc都会吗？

- CMS收集器的工作流程主要有下面4个步骤：
1. 初始标记：标记所有从GCRoot直接可达的对象。这一步骤需要STW，即暂停所有应用线程，但由于只标记直接可达的对象，因此这个阶段通常很快。
2. 并发标记：从初始标记阶段标记的对象出发，遍历整个对象图，标记所有可达的对象。在此阶段，GC线程与应用线程同时运行，不需要STW。（预清理：这一阶段也是并发执行的，目的是在实际清理前，处理并发标记阶段结束后和重新标记阶段开始前这段时间内发生的变化。目的是减少重新标记阶段的工作量。）
3. 重新标记：这一阶段是为了修正并发标记期间因应用线程继续运行而产生的更改。这是另一个需要STW的阶段。
4. 并发清理：在此阶段，GC线程清除不可达的对象，并回收它们占用的内存空间。这个阶段与应用线程并发执行，不需要STW。

**CMS的过程中，只有初始标记和重新标记这两个步骤是STW的，所以，相比其他的收集器整个回收过程都STW来说，他导致的应用停顿时间更短**



- 跨代引用
  
  - **JVM的跨代引用问题是指在Java堆内存的不同代之间存在引用关系**，导致对象在不同代之间的引用被称为跨代引用。比如：新生代到老年代的引用，老年代到新生代的引用等。
  
  - 解决：1、在做YoungGC的时候，GC Root出发后扫描到老年代对象后不中断，继续扫描和标记，把所有在年轻代的对象都标记上。
    
    2、在YoungGC的实时，把老年代的所有对象也作为GC Root，进行可达性分析扫描。
    
    以上两种做法，其实成本都太高了，甚至第一种要比第二种成本还要高，因为他不仅要扫描，还需要不断地做标记。
    
    那么，于是就有一个好的办法出现了，那就是定义了一个全局的数据结构——**Remembered Set**。

- GC Roots可以是哪些元素？

> - 虚拟机栈中引用的对象
>   - 比如：各个线程被调用的方法中使用到的参数、局部变量等。
> - 本地方法栈内JNI（通常说的本地方法）引用的对象
> - 方法区中类静态属性引用的对象
>   - 比如：Java类的引用类型静态变量
> - 方法区中常量引用的对象
>   - 比如：字符串常量池（StringTable）里的引用
> - 所有被同步锁synchronized持有的对象
> - Java虚拟机内部的引用。
>   - 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。
> - 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

## 安全点了解吗？如果有一段代码进不了安全点怎么办？什么是安全区域？除了GC还有其他场景用安全点吗？锁降级、Dump、jit、热替换

**安全点，简单点说就是代码执行过程中的一些特殊位置，当线程执行到这个位置的时候，可以被认为处于“安全状态”，如果有需要，可以在这里暂停，在这里暂停是安全的**

**当JVM需要对线程进行挂起的时候，会等到安全点在执行。**

安全点确保了线程在可预测和一致的状态下停止。提及的各种操作，如GC、JIT优化、偏向锁撤销、线程Dump等的，都需要JVM能保证线程不会再修改共享数据，那如何保证呢？那就是安全点了。

## Java的类加载机制。双亲委派模型。有哪些类加载器？bootstrap、ext、app，哪个版本是这样的？后面有变化吗？

Java中类的加载阶段分为加载（Loading）、链接（Linking）和初始化（Initialization）。其中连接过程又包含了验证、准备和解析。

**加载阶段的目的是将类的.class文件加载到JVM中**。

**在链接阶段**，Java类加载器对类进行验证、准备和解析操作。将类与类的关系（符号引用转为直接引用）确定好，校验字节码

1. **验证**：校验类的正确性（文件格式，元数据，字节码，二进制兼容性），保证类的结构符合JVM规范。
2. **准备**：为类变量分配内存并设置类变量的默认初始值，这些变量使用的内存都在方法区中分配。（这里初始化的是类变量，即static字段，实例变量会在对象实例化时随对象一起分配在Java堆中。）
3. **解析**：把类的符号引用转为直接引用*(类或接口、字段、类方法、接口方法、方法类型、方法句柄和访问控制修饰符7类符号引用 )*

**初始化阶段**是执行类构造器 `<clinit> ()`方法的过程。这**里利用了一种懒加载的思想，所有Java虚拟机实现（如HotSpot等）必须在每个类或接口被Java程序首次主动使用时才初始化**，但类加载不一定，静态代码块在类**初始化**时执行

1. 当遇到 new 、 getstatic、putstatic或invokestatic 这4条字节码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时会进行类的初始化
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类
5. 当使用 JDK1.7 的动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化

加载器：启动类加载器、扩展类加载器、系统类加载器

- JDK 1.9及以后

在JDK 9中，类加载器发生了一些变化，原来的扩展类加载器被重命名为**平台类加载器**

## JDK 8以后的版本有哪些新特性？模块化知道吗？ZGC了解吗？

- JDK 8中推出了Lambda表达式、Stream、Optional、新的日期API等

引入了Lambda表达式，允许使用简洁的语法来编写匿名函数

函数式接口和Stream API使得函数式编程在Java中变得更加容易和直观

引入了Optional类来避免空指针异常，提供了更好的日期和时间处理方式，取代了旧的Date类。

- JDK 9中推出了模块化，模块化系统使得应用可以按需打包和加载模块，降低了应用的启动时间和内存占用，增强了封装性和安全性。

JDK 10中推出了本地变量类型推断

JDK 12中增加了switch表达式

JDK 13中增加了text block

JDK 14中增加了Records，一种用于简洁地声明不可变数据类的方式

JDK 14中增加了instance模式匹配

JDK 15中增加了封闭类

JDK 17中扩展了switch模式匹配

JDK 21中增加了协程

ZGC垃圾收集器作为JDK 11及以后版本中的一个重要特性，提供了低延迟、高吞吐量和可扩展性的垃圾回收解决方案 旨在提供可预测的停顿时间，同时保持高吞吐量。

## G1知道吗，和CMS区别？位置、算法、AOT编译知道吗？

- G1可以独立管理整个GC堆，包括年轻代和老年代；CMS是老年代的收集器；

- G1从整体上看是基于“标记-整理”算法实现，从局部上来看是基于“标记-复制”算法实现；CMS收集器是使用“标记-清除”算法进行的垃圾回收；

2、**AOT编译**，翻译一下就是提前编译，它不像JIT一样在运行期才生成机器码，而是在编译期间就将字节码转换为机器码，这就直接省去了运行时对JVM的依赖。这是一种典型的静态编译技术。

G1会把Java的堆分为多个大小相等的Region（每个Region的大小为1M-32M），他在年轻代回收的时候采用标记-复制算法，而在老年代回收的时候，采用的是标记-整理算法，这两种算法都可以避免内存碎片的产生。

G1在回收的过程中，标记和清理的过程是并行的，可以充分利用多个CPU来缩短STW的时长，在复制的过程中是并发的，可以让复制线程和用户线程并发执行，不需要STW。并且G1还可以在运行时动态的做区域内存大小的调整。

## 设计模式用过吗？多个支付渠道的实现，用什么设计模式实现？策略+模板+工厂

**一般在工作中，是可以把策略、工厂和模板一起结合着来使用的。**

## 频繁FullGC排查如何做？dump、MAT。

1、 开启详细的GC日志记录，通过设置 JVM参数，如`-Xloggc:file_name`、`-XX:+PrintGCDetails`和`-XX:+PrintGCDateStamps`，来记录GC活动的详细信息。

2、使用Java VisualVM、Memory Analyzer Tool等工具进行分析

3、使用工具如jvisualvm来监控JVM内存使用情况

4、使用jmap生成堆存储文件

## 如何获取dump？dump之前发生了GC怎么办？

1、首先，找到Java进程的进程ID（PID），可以使用jps命令或ps命令来获取。

      然后，运行jstack命令并指定PID来生成线程dump文件

2、使用其他监控工具（如jvisualvm、JMC等）来实时监视JVM的性能和内存使用情况。

3、分别对存在FullGC的机器、当前堆内存占用比较高的机器、以及内存占用并不高也没有频繁GC的机器进行了dump。**之所有多次dump，主要是为了作对比。**

## 不做dump能定位fullgc原因吗？

1. **分析GC日志**：
   
   - GC日志记录了JVM在执行垃圾收集时的详细信息，包括每次GC的时间、回收的内存量、GC的类型（如Minor GC、Full GC）等。
   - 通过分析GC日志，可以找出Full GC发生的规律和原因。例如，如果每次Full GC都回收了大量的内存，那么可能是存在内存泄露或者大对象问题；如果Full GC发生得很频繁，那么可能是堆大小设置不合理或者垃圾收集器配置不当。
   
   2、**监控JVM性能**
- 使用JVM监控工具（如JConsole、VisualVM等）可以实时监控JVM的内存使用情况、垃圾收集情况等信息。

3、**检查代码**：

- 审查代码以查找可能导致内存泄露或频繁创建对象的逻辑。特别是与缓存中间件交互的部分，需要检查是否存在未释放的连接或未正确管理对象生命周期的情况。
- 查找大对象或长生命周期对象，这些对象可能占用大量内存并导致Full GC。
